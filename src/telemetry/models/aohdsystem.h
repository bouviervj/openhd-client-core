#ifndef AOHDSYSTEM_H
#define AOHDSYSTEM_H

#include <array>
#include <atomic>

#include "../tutil/mavlink_include.h"

#include "tutil/openhd_defines.hpp"

#include "../timer/Timer.h"

/**
 * Abstract OHD (Mavlink) system.
 * This class contains information (basically like a model) about one OpenHD Air or Ground instance (if connected).
 * A (Abstract) because it is mostly for functionalities that are always supported by both air and ground.
 * For example, both the air and ground unit report the CPU usage and more, and this data is made available to QT UI using a instance of this model.
 * NOTE: FC telemetry has nothing to do here, as well as air / ground specific things.
 * NOTE: In QOpenHD, there are 2 instances of this model, named "_ohdSystemGround" and "_ohdSystemAir" (registered in main)
 * They each correspond to the apropriate singleton instance (instanceGround() and instanceAir() )
 */
class AOHDSystem 
{

public:
    explicit AOHDSystem(const bool is_air);
    // Singletons for accessing the models from c++
    static AOHDSystem& instanceAir();
    static AOHDSystem& instanceGround();
    //Process OpenHD custom flavour message(s) coming from either the OHD Air or Ground unit
    // Returns true if the passed message was processed (known message id), false otherwise
    bool process_message(const mavlink_message_t& msg);
public: // public for QT
    // NOTE: I wrote this class before I knew about the lqutils macros, which is why they are used sparingly here
    //
    // WB / Monitor mode link statistics, generic for both air and ground (incoming / outgoing)
    int curr_rx_packet_loss_perc = -1;
    void set_curr_rx_packet_loss_perc(int value) { curr_rx_packet_loss_perc = value; }
    long long int count_tx_inj_error_hint = 0;
    void set_count_tx_inj_error_hint(long long int value) { count_tx_inj_error_hint = value; }
    long long int count_tx_dropped_packets = 0;
    void set_count_tx_dropped_packets(long long int value) { count_tx_dropped_packets = value; }
    // telemetry specific
    std::string curr_telemetry_tx_pps = "-1pps";
    void set_curr_telemetry_tx_pps(std::string value) { curr_telemetry_tx_pps = value; }
    std::string curr_telemetry_rx_pps = "-1pps";
    void set_curr_telemetry_rx_pps(std::string value) { curr_telemetry_rx_pps = value; }
    std::string curr_telemetry_tx_bps = "-1bps";
    void set_curr_telemetry_tx_bps(std::string value) { curr_telemetry_tx_bps = value; }
    std::string curr_telemetry_rx_bps = "-1bps";
    void set_curr_telemetry_rx_bps(std::string value) { curr_telemetry_rx_bps = value; }
    // microhard specific
    int microhard_enabled = 0;
    void set_microhard_enabled(int value) { microhard_enabled = value; }
    int microhard_rssi = 0;
    void set_microhard_rssi(int value) { microhard_rssi = value; }
    int microhard_tx_pwr = 0;
    void set_microhard_tx_pwr(int value) { microhard_tx_pwr = value; }
    int microhard_bw = 0;
    void set_microhard_bw(int value) { microhard_bw = value; }
    int microhard_freq = 0;
    void set_microhard_freq(int value) { microhard_freq = value; }
    int microhard_noise = 0;
    void set_microhard_noise(int value) { microhard_noise = value; }
    int microhard_snr = 0;
    void set_microhard_snr(int value) { microhard_snr = value; }
    //
    // The following stats only exist on the air instance, since they are only generated by OpenHD air unit
    // for the UI, if his value is set we show a warning below the bitrate icon to the user
    // a TX dropping packets means the user set a vieo bitrate that is too high
    bool tx_is_currently_dropping_packets = false;
    void set_tx_is_currently_dropping_packets(bool value) { tx_is_currently_dropping_packets = value; }
    //
    // --------- SOC statistics, generic for both air and ground
    // based on RPI SOC
    int curr_cpuload_perc = 0;
    void set_curr_cpuload_perc(int value) { curr_cpuload_perc = value; }
    int curr_soc_temp_degree = 0;
    void set_curr_soc_temp_degree(int value) { curr_soc_temp_degree = value; }
    int curr_txc_temp_degree_1 = 0;
    void set_curr_txc_temp_degree_1(int value) { curr_txc_temp_degree_1 = value; }
    int curr_txc_temp_degree_2 = 0;
    void set_curr_txc_temp_degree_2(int value) { curr_txc_temp_degree_2 = value; }
    int curr_cpu_freq_mhz = 0;
    void set_curr_cpu_freq_mhz(int value) { curr_cpu_freq_mhz = value; }
    int curr_isp_freq_mhz = 0;
    void set_curr_isp_freq_mhz(int value) { curr_isp_freq_mhz = value; }
    int curr_h264_freq_mhz = 0;
    void set_curr_h264_freq_mhz(int value) { curr_h264_freq_mhz = value; }
    int curr_core_freq_mhz = 0;
    void set_curr_core_freq_mhz(int value) { curr_core_freq_mhz = value; }
    int curr_v3d_freq_mhz = 0;
    void set_curr_v3d_freq_mhz(int value) { curr_v3d_freq_mhz = value; }
    int curr_space_left_mb = 0;
    void set_curr_space_left_mb(int value) { curr_space_left_mb = value; }
    int ram_usage_perc = 0;
    void set_ram_usage_perc(int value) { ram_usage_perc = value; }
    int ram_total = 0;
    void set_ram_total(int value) { ram_total = value; }
    int ohd_platform_type = -1;
    void set_ohd_platform(int value) { ohd_platform_type = value; }
    std::string ohd_platform_type_as_string = "N/A";
    void set_ohd_platform_type_as_string(std::string value) { ohd_platform_type_as_string = value; }
    int ohd_wifi_type = 0;
    void set_ohd_wifi(int value) { ohd_wifi_type = value; }
    int ohd_cam_type = 0;
    void set_ohd_cam(int value) { ohd_cam_type = value; }
    int ohd_sys_type = 0;
    void set_ohd_sys_ident(int value) { ohd_sys_type = value; }
    // RPI only
    bool rpi_undervolt_error = false;
    void set_rpi_undervolt_error(bool value) { rpi_undervolt_error = value; }
    // needs ina219 sensor
    int ina219_voltage_millivolt = 0;
    void set_ina219_voltage_millivolt(int value) { ina219_voltage_millivolt = value; }
    int ina219_current_milliamps = 0;
    void set_ina219_current_milliamps(int value) { ina219_current_milliamps = value; }
    // This basically only makes sense on the ground pi, it is not the battery percentage reported by the FC
    // but the battery percentage reported by the COmpanion computer running OpenHD (if it is supported, aka for future power hat o.Ã¤)
    int battery_percent = 0;
    void set_battery_percent(int value) { battery_percent = value; }
    std::string battery_gauge = "\uf091";
    void set_battery_gauge(std::string value) { battery_gauge = value; }
    // needs to be queried explicitly (not continous fire and forget)
    std::string openhd_version = "N/A";
    void set_openhd_version(std::string value) { openhd_version = value; }
    std::string last_ping_result_openhd = " ";
    void set_last_ping_result_openhd(std::string value) { last_ping_result_openhd = value; }
    bool m_is_alive = false;
    void set_is_alive(bool value) { m_is_alive = value; }
    //
    int m_current_rx_rssi = -128;
    void set_current_rx_rssi(int value) { m_current_rx_rssi = value; }
    int m_current_rx_signal_quality = -1;
    void set_current_rx_signal_quality(int value) { m_current_rx_signal_quality = value; }
    //
    int _wifi_rx_packets_count = -1;
    void wifi_rx_packets_count(int value) { _wifi_rx_packets_count = value; }
    int _wifi_tx_packets_count = -1;
    void wifi_tx_packets_count(int value) { _wifi_tx_packets_count = value; }
    // The MCS index is a param, but also broadcasted in regular intervals, since it might change (during flight / link adjustments)
    // We also create a message in the HUD every time MCS changes
    int m_curr_mcs_index = -1;
    void set_curr_mcs_index(int value) { m_curr_mcs_index = value; }
    int m_curr_bitrate_kbits = -1;
    void set_curr_bitrate_kbits(int value) { m_curr_bitrate_kbits = value; }
    int m_curr_n_rate_adjustments = -1;
    void set_curr_n_rate_adjustments(int value) { m_curr_n_rate_adjustments = value; }

    // similar for channel / channel width
    int m_curr_channel_mhz = -1;
    void set_curr_channel_mhz(int value) { m_curr_channel_mhz = value; }
    int m_curr_channel_width_mhz = -1;
    void set_curr_channel_width_mhz(int value) { m_curr_channel_width_mhz = value; }
    // 0: can do tx and rx, 1=card can (probably) only do rx 2=passive / listen only mode actively enabled
    int m_tx_operating_mode = 0;
    void set_tx_operating_mode(int value) { m_tx_operating_mode = value; }
    // wifibroadcast options
    bool m_wb_stbc_enabled = false;
    void set_wb_stbc_enabled(bool value) { m_wb_stbc_enabled = value; }
    bool m_wb_lpdc_enabled = false;
    void set_wb_lpdc_enabled(bool value) { m_wb_lpdc_enabled = value; }
    bool m_wb_short_guard_enabled = false;
    void set_wb_short_guard_enabled(bool value) { m_wb_short_guard_enabled = value; }
    bool m_curr_rx_last_packet_status_good = false;
    void set_curr_rx_last_packet_status_good(bool value) { m_curr_rx_last_packet_status_good = value; }
    //
    std::string m_tx_packets_per_second_and_bits_per_second = "N/A";
    void set_tx_packets_per_second_and_bits_per_second(std::string value) { m_tx_packets_per_second_and_bits_per_second = value; }
    std::string m_rx_packets_per_second_and_bits_per_second = "N/A";
    void set_rx_packets_per_second_and_bits_per_second(std::string value) { m_rx_packets_per_second_and_bits_per_second = value; }
    std::string m_tx_tele_packets_per_second_and_bits_per_second = "N/A";
    void set_tx_tele_packets_per_second_and_bits_per_second(std::string value) { m_tx_tele_packets_per_second_and_bits_per_second = value; }
    std::string m_rx_tele_packets_per_second_and_bits_per_second = "N/A";
    void set_rx_tele_packets_per_second_and_bits_per_second(std::string value) {m_rx_tele_packets_per_second_and_bits_per_second = value; }
    // Set to 2 as soon as we receve a broadcast message for secondary camera from qopenhd
    int n_openhd_cameras = -1;
    void set_n_openhd_cameras(int value) { n_openhd_cameras = value; }
    // 0==no warning, 1== orange 2==red
    int m_dbm_too_low_warning = 0;
    void set_dbm_too_low_warning(int value) { m_dbm_too_low_warning = value; }
    //
    int m_wb_link_pollution_perc = -1;
    void set_wb_link_pollution_perc(int value) { m_wb_link_pollution_perc = value; }
    int m_wb_link_curr_foreign_pps = -1;
    void set_wb_link_curr_foreign_pps(int value) { m_wb_link_curr_foreign_pps = value; }
    // ---------- WIFI HOTSPOT ----------------------
    int m_wifi_hotspot_state = -1; // 0 - not available, 1 - off, 2 - on
    void set_wifi_hotspot_state(int value) { m_wifi_hotspot_state = value; }
    int m_wifi_hotspot_frequency = -1;
    void set_wifi_hotspot_frequency(int value) { m_wifi_hotspot_frequency = value; }
    int m_external_devices_count = -1;
    void set_external_devices_count(int value) { m_external_devices_count = value; }
    //
    int m_wb_gnd_operating_mode = -1;
    void set_wb_gnd_operating_mode(int value) { m_wb_gnd_operating_mode = value; }
    //
    int m_air_reported_fc_sys_id = -1;
    void set_air_reported_fc_sys_id(int value) { m_air_reported_fc_sys_id = value; }
    //
    bool m_dirty_air_has_secondary_cam = false;
    void set_dirty_air_has_secondary_cam(bool value) { m_dirty_air_has_secondary_cam = value; }
    // x20 only right now
    int m_thermal_protection_level = -1;
    void set_thermal_protection_level(int value) { m_thermal_protection_level = value; }
public:
    std::string get_rate_for_mcs_bw(int mcs,int bw) const;
private:
    const bool m_is_air; // either true (for air) or false (for ground)
     uint8_t get_own_sys_id()const{
        return m_is_air ? OHD_SYS_ID_AIR : OHD_SYS_ID_GROUND;
     }
     // These are for handling the slight differences regarding air/ ground properly, if there are any
     // For examle, the onboard computer status is the same when coming from either air or ground,
     // but the stats total are to be interpreted slightly different for air and ground.
     void process_onboard_computer_status(const mavlink_onboard_computer_status_t& msg);
     void process_x0(const mavlink_openhd_stats_monitor_mode_wifi_card_t& msg);
     void process_x1(const mavlink_openhd_stats_monitor_mode_wifi_link_t& msg);
     void process_x2(const mavlink_openhd_stats_telemetry_t& msg);
     void process_x3(const mavlink_openhd_stats_wb_video_air_t& msg);
     void process_x3b(const mavlink_openhd_stats_wb_video_air_fec_performance_t& msg);
     void process_x4(const mavlink_openhd_stats_wb_video_ground_t& msg);
     void process_x4b(const mavlink_openhd_stats_wb_video_ground_fec_performance_t& msg);
     void process_sys_status1(const mavlink_openhd_sys_status1_t& msg);
     void process_op_mode(const mavlink_openhd_wifbroadcast_gnd_operating_mode_t& msg);
     // When apropriate, auto-fecth params until success
     void autofech_params_if_apropriate();
private:
     std::atomic<int64_t> m_last_heartbeat_ms = -1;
     std::atomic<int64_t> m_last_message_ms= -1;
     //
     std::string m_curr_incoming_bitrate="Bitrate NA";
     std::string m_curr_incoming_tele_bitrate="Bitrate NA";
     //
private:
    // Sets the alive boolean if no heartbeat / message has been received in the last X seconds
    std::unique_ptr<Timer> m_alive_timer = nullptr;
    void update_alive();
    std::chrono::steady_clock::time_point m_last_message_openhd_stats_total_all_wifibroadcast_streams=std::chrono::steady_clock::now();
    // Model / fire and forget data only end
private:
    int64_t x_last_dropped_packets=-1;
private:
     // do not completely pollute the HUD with this error message
    std::chrono::steady_clock::time_point m_last_tx_error_hud_message=std::chrono::steady_clock::now();
    std::chrono::steady_clock::time_point m_last_n_cameras_message=std::chrono::steady_clock::now();
    void update_alive_status_with_hud_message(bool alive);
private:
    bool m_x20_rpi_upgrade_warning_logged=false;
};



#endif // AOHDSYSTEM_H
