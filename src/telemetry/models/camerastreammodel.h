#ifndef AIRCAMERAMODEL_H
#define AIRCAMERAMODEL_H

#include "../tutil/mavlink_include.h"

#include <vector>
#include <string>
#include <chrono>

struct QCameraNameAndType{
    std::string name;
    int type;
};
struct QManufacturerForPlatform{
    std::string manufacturer_name;
    std::vector<QCameraNameAndType> cameras;
};

// NOTE1: This class exists to avoid duplicated code for primary and secondary camera(stream)-stats displayed in the HUD
// NOTE2: Here we have only stats for one camera / camera stream that are transmitted via lossy
// telemetry messages, aka in regular intervalls.
// NOTE3: Camera settings or similar you won't find here, and it is also discouraged to use the data here
// for anything else than display-only HUD elements. See MavlinkSettingsModel and instanceAirCamera();
// This model can be viewed as an "extension" of AOHDSystem, it is also updated from there
class CameraStreamModel
{
public:
    explicit CameraStreamModel(int m_camera_index);
    const int m_camera_index;
    static CameraStreamModel& instance(int cam_index);
public:
    std::string m_xx_cam_type = "ARDUCAM SKYMASTER HDR";
    void set_xx_cam_type(std::string value) { m_xx_cam_type = value; }
    std::string m_xx_cam_status = "OK";
    void set_xx_cam_status(std::string value) { m_xx_cam_status = value; }

    // Width x height @ fps for a camera
    std::string m_curr_set_video_format = "";
    void set_curr_set_video_format(std::string value) { m_curr_set_video_format = value; }
    // Width x height @ fps and codec for camera
    std::string m_curr_set_video_format_and_codec = "N/A";
    void set_curr_set_video_format_and_codec(std::string value) { m_curr_set_video_format_and_codec = value; }
    //
    // The following stats are kinda camera related, kinda wb link related
    // They area also only generated by OpenHD air unit.
    // Regarding encoder recommended video bitrate: This value is broadcasted in regular intervals by the openhd air unit,
    // If variable bitrate is disabled, it is the value set by the mavlink parameter (duplicate) but if variable bitrate is enabled,
    // it is the value the openhd air unit currently recommends to the encoder
    std::string m_curr_recomended_video_bitrate_string = "N/A";
    void set_curr_recomended_video_bitrate_string(std::string value) { m_curr_recomended_video_bitrate_string = value; }
    int m_curr_recomended_video_bitrate_kbits = 0;
    void set_curr_recomended_video_bitrate_kbits(int value) { m_curr_recomended_video_bitrate_kbits = value; }
    std::string m_curr_video_measured_encoder_bitrate = "N/A";
    void set_curr_video_measured_encoder_bitrate(std::string value) { m_curr_video_measured_encoder_bitrate = value; }
    std::string m_curr_video_injected_bitrate = "N/A";
    void set_curr_video_injected_bitrate(std::string value) { m_curr_video_injected_bitrate = value; }
    std::string m_curr_video_injected_pps = "-1pps";
    void set_curr_video_injected_pps(std::string value) { m_curr_video_injected_pps = value; }
    // total n of frames that were dropped on the tx (hints at too high bitrate)
    int m_total_n_tx_dropped_frames = 0;
    void set_total_n_tx_dropped_frames(int value) { m_total_n_tx_dropped_frames = value; }
    // calculated in fixed X second interval(s) - n of tx frames dropped during this interval
    int m_curr_delta_tx_dropped_frames = 0;
    void set_curr_delta_tx_dropped_frames(int value) { m_curr_delta_tx_dropped_frames = value; }
    // DEV stats
    std::string m_curr_fec_encode_time_avg_min_max = "avg na, min na, max na";
    void set_curr_fec_encode_time_avg_min_max(std::string value) { m_curr_fec_encode_time_avg_min_max = value; }
    std::string m_curr_fec_block_length_min_max_avg = "avg na, min na, max na";
    void set_curr_fec_block_length_min_max_avg(std::string value) { m_curr_fec_block_length_min_max_avg = value; }
    std::string m_curr_time_until_tx_min_max_avg = "avg na, min na, max na";
    void set_curr_time_until_tx_min_max_avg(std::string value) { m_curr_time_until_tx_min_max_avg = value; }
    // Used to show the user a visual indication that the set and measured encoder bitrate are far apart
    // 0 - all okay, 1= bitrate is too low (yellow), 2= bitrate is too high (red)
    int m_curr_set_and_measured_bitrate_mismatch = 0;
    void set_curr_set_and_measured_bitrate_mismatch(int value) { m_curr_set_and_measured_bitrate_mismatch = value; }
    //
    int m_curr_fec_percentage = -1;
    void set_curr_curr_fec_percentage(int value) { m_curr_fec_percentage = value; }
    int m_curr_keyframe_interval = -1;
    void set_curr_curr_keyframe_interval(int value) { m_curr_keyframe_interval = value; }
    bool m_air_recording_active = false;
    void set_air_recording_active(bool value) { m_air_recording_active = value; }
    std::string m_air_tx_packets_per_second_and_bits_per_second = "N/A";
    void set_air_tx_packets_per_second_and_bits_per_second(std::string value) { m_air_tx_packets_per_second_and_bits_per_second = value; }
    // UI might change slightly depending on the camera type
    int m_camera_type = -1;
    void set_camera_type(int value) { m_camera_type = value; }
    int m_camera_status = -1;
    void set_camera_status(int value) { m_camera_status = value; }
    int m_encoding_codec = -1;
    void set_encoding_codec(int value) { m_encoding_codec = value; }
    //
    // These are generated by the OpenHD ground unit
    //
    std::string m_curr_received_bitrate_with_fec = "N/A";
    void set_curr_received_bitrate_with_fec(std::string value) { m_curr_received_bitrate_with_fec = value; }
    int64_t m_count_blocks_total = -1;
    void set_count_blocks_total(int64_t value) { m_count_blocks_total = value; }
    int64_t m_count_blocks_lost = -1;
    void set_count_blocks_lost(int64_t value) { m_count_blocks_lost = value; }
    int64_t m_count_blocks_recovered = -1;
    void set_count_blocks_recovered(int64_t value) { m_count_blocks_recovered = value; }
    int64_t m_count_fragments_recovered = -1;
    void set_count_fragments_recovered(int64_t value) { m_count_fragments_recovered = value; }
    std::string m_curr_fec_decode_time_avg_min_max = "avg na, min na, max na";
    void set_curr_fec_decode_time_avg_min_max(std::string value) { m_curr_fec_decode_time_avg_min_max = value; }
public:
     std::string camera_type_to_string(int camera_type);
     std::string camera_status_to_string(int camera_status);
     std::string camera_codec_to_string(int camera_codec);
     std::string camera_recording_mode_to_string(int recording_mode);
     bool is_valid_resolution_fps_string(std::string input);
     std::string get_default_resolution();
     std::vector<std::string> get_supported_resolutions();
     std::string make_resolution_fps_verbose(std::string input);
public:
    // generated by wb / link
    void update_mavlink_openhd_stats_wb_video_air(const mavlink_openhd_stats_wb_video_air_t &msg);
    void update_mavlink_openhd_stats_wb_video_air_fec_performance(const mavlink_openhd_stats_wb_video_air_fec_performance_t &msg);
    void update_mavlink_openhd_stats_wb_video_ground(const mavlink_openhd_stats_wb_video_ground_t &msg);
    void update_mavlink_openhd_stats_wb_video_ground_fec_performance(const mavlink_openhd_stats_wb_video_ground_fec_performance_t &msg);
    // generated by the camera
    void update_mavlink_openhd_camera_status_air(const mavlink_openhd_camera_status_air_t & msg);
private:
    // We use the fact that the current recommended bitrate is updated regularily to notify the user of
    // changing rate(s) during flight
    void set_curr_recommended_bitrate_from_message(int64_t curr_recommended_bitrate_kbits);
    // Do not completely pollute the Log messages model
    int m_n_mismatch_has_been_logged=0;
    // FEAUTURE - Re-start decoding if resolution / framerate of a camera has changed
    struct ResolutionFramerate{
        int width=-1;
        int height=-1;
        int framerate=-1;
        bool operator==(const ResolutionFramerate &o) const {
            return this->framerate==o.framerate && this->width==o.width && this->height==o.height;
        }
        bool operator !=(const ResolutionFramerate &o) const {
            return !(*this==o);
        }
        bool is_any_invalid()const{
            return (width==-1 || width==0 ||
                   height==-1 || height==0 ||
                    framerate==-1 || framerate==0);
        }
    };
    static std::string resolution_framerate_to_string(const ResolutionFramerate& data);
    ResolutionFramerate m_curr_res_framerate{};
    std::chrono::steady_clock::time_point m_last_hud_message_camera_status=std::chrono::steady_clock::now();
private:
    std::chrono::steady_clock::time_point m_last_tx_frame_drop_calculation=std::chrono::steady_clock::now();
    int m_last_tx_frame_drop_calculation_count=-1;
public:
     std::vector<QCameraNameAndType> get_camera_choices(int platform_type);
     std::vector<std::string> get_manufacturer_choices(int platform_type);
     std::vector<int> get_manufacturer_cameras_type(int platform_type,int index);
     std::vector<std::string> get_manufacturer_cameras_names(int platform_type,int index);
};

#endif // AIRCAMERAMODEL_H
